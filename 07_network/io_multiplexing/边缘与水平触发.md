边缘触发（Edge-Triggered, ET）和水平触发（Level-Triggered, LT）是 `epoll` 的两种事件通知模式，它们的核心差异决定了各自的适用场景。以下是分点对比和典型应用场景：

---

### **1. 边缘触发（ET）**
#### **核心特性**
- **触发条件**：仅在fd状态**变化时**通知一次（例如从无数据到有数据）。
- **数据未读完的后果**：内核不再通知，除非有新数据到达。
- **必须搭配**：非阻塞IO + 循环读写直到 `EAGAIN`。

#### **适用场景**
| **场景**                | **原因**                                                                 |
|-------------------------|-------------------------------------------------------------------------|
| **高频低延迟**          | 减少重复事件通知（如游戏服务器、金融交易系统）                          |
| **高并发长连接**        | 避免对空闲连接的无意义唤醒（如WebSocket服务）                           |
| **精确控制IO**          | 开发者需手动管理读写节奏（如自定义协议解析）                            |
| **CPU密集型应用**       | 减少内核-用户态切换开销（如音视频流处理）                              |

#### **代码示例**
```c
// ET模式必须非阻塞 + 循环读取
fcntl(fd, F_SETFL, O_NONBLOCK);
while (1) {
    ssize_t n = read(fd, buf, sizeof(buf));
    if (n == -1 && errno == EAGAIN) break; // 数据读完
    if (n <= 0) { /* 处理错误或关闭 */ break; }
    process_data(buf, n);
}
```

---

### **2. 水平触发（LT）**
#### **核心特性**
- **触发条件**：只要fd处于就绪状态（如缓冲区有数据），**持续通知**。
- **数据未读完的后果**：内核会反复通知，直到数据被读完。
- **兼容性**：支持阻塞和非阻塞IO。

#### **适用场景**
| **场景**                | **原因**                                                                 |
|-------------------------|-------------------------------------------------------------------------|
| **传统网络服务**        | 简化编程逻辑（如HTTP服务器、MySQL）                                    |
| **短连接场景**          | 连接生命周期短，无需复杂状态管理（如REST API）                          |
| **开发效率优先**        | 避免手动处理数据残留（如快速原型开发）                                  |
| **低并发或调试阶段**    | 更易排查问题（事件通知不会遗漏）                                        |

#### **代码示例**
```c
// LT模式可简化处理（无需强制循环）
ssize_t n = read(fd, buf, sizeof(buf));
if (n > 0) {
    process_data(buf, n);  // 未读完的数据下次会再次触发EPOLLIN
} else if (n <= 0) {
    close(fd);
}
```

---

### **3. 关键对比**
| **维度**         | **边缘触发（ET）**                     | **水平触发（LT）**                   |
|------------------|--------------------------------------|--------------------------------------|
| **事件通知频率** | 仅状态变化时一次                      | 持续通知直到数据耗尽                  |
| **数据完整性**   | 依赖开发者手动读完                    | 内核保证数据不丢失                    |
| **性能开销**     | 更低（减少无效唤醒）                  | 更高（可能重复通知）                  |
| **编程复杂度**   | 高（需非阻塞+循环读写）               | 低（直接处理单次事件）                |
| **适用连接数**   | 10万+高并发                          | 1万以下中低并发                       |

---

### **4. 选择建议**
- **用ET如果**：  
  - 需要极致性能  
  - 能保证正确处理数据边界（如自定义协议）  
  - 开发团队熟悉非阻塞IO编程  

- **用LT如果**：  
  - 追求开发效率  
  - 使用标准协议（如HTTP）  
  - 并发量中等或调试阶段  

---

### **5. 经典案例**
1. **Nginx**：默认使用ET模式，最大化吞吐量  
2. **Redis**：采用ET模式处理数万并发连接  
3. **Apache**：传统LT模式，适合通用Web服务  

---

### **总结**
- **ET**：高性能场景的终极武器，但需谨慎处理数据边界。  
- **LT**：简单可靠，适合大多数普通应用。  

根据业务需求和团队能力选择模式，**若不确定，优先使用LT**。